# 1. K번째 약수
# 다른 방법으로...
n=6 
k=1
cnt=0
a=[]
for i in range(1, n+1):
    if n%i==0:
        cnt+=1
        a.append(i)

if(k > len(a)):
  print(-1)
else: 
  print(a[k-1])

# 2. K번째 수
# 강의 들을 것!!
# 안들어도 됨
import sys
sys.stdin=open("input.txt", "r")
T=int(input())
for t in range(T):
    n, s, e, k=map(int, input().split())
    a=list(map(int, input().split()))
    a=a[s-1:e]
    a.sort()
    print("#%d %d" %(t+1, a[k-1]))

n=6
s=2
e=5
k=3
a=[5,2,7,3,8,9]
a=a[s-1:e]
a.sort()
print((1, a[k-1]))

# 3. K번째 큰수
# 강의 들을 것!!

집합 자료형
집합 자료형은 다음과 같이 set 키워드를 사용해 만들 수 있다.

>>> s1 = set([1,2,3])
>>> s1
{1, 2, 3}
위와 같이 set()의 괄호 안에 리스트를 입력하여 만들거나 다음과 같이 문자열을 입력하여 만들 수도 있다.

>>> s2 = set("Hello")
>>> s2
{'e', 'H', 'l', 'o'}
※ 비어 있는 집합 자료형은 s = set()로 만들수 있다.

집합 자료형의 특징
자, 그런데 위에서 살펴본 set("Hello")의 결과가 좀 이상하지 않은가? 분명 "Hello" 문자열로 set 자료형을 만들었는데 생성된 자료형에는 l 문자가 하나 빠져 있고 순서도 뒤죽박죽이다. 그 이유는 set에 다음과 같은 2가지 큰 특징이 있기 때문이다.

중복을 허용하지 않는다.
순서가 없다(Unordered).
리스트나 튜플은 순서가 있기(ordered) 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있지만 set 자료형은 순서가 없기(unordered) 때문에 인덱싱으로 값을 얻을 수 없다. 이는 마치 02-5에서 살펴본 딕셔너리와 비슷하다. 딕셔너리 역시 순서가 없는 자료형이라 인덱싱을 지원하지 않는다.

만약 set 자료형에 저장된 값을 인덱싱으로 접근하려면 다음과 같이 리스트나 튜플로 변환한후 해야 한다.

※ 중복을 허용하지 않는 set의 특징은 자료형의 중복을 제거하기 위한 필터 역할로 종종 사용하기도 한다.

>>> s1 = set([1,2,3])
>>> l1 = list(s1)
>>> l1
[1, 2, 3]
>>> l1[0]
1
>>> t1 = tuple(s1)
>>> t1
(1, 2, 3)
>>> t1[0]
1

교집합, 합집합, 차집합 구하기
set 자료형을 정말 유용하게 사용하는 경우는 교집합, 합집합, 차집합을 구할 때이다.

우선 다음과 같이 2개의 set 자료형을 만든 후 따라 해 보자. s1은 1부터 6까지의 값을 가지게 되었고, s2는 4부터 9까지의 값을 가지게 되었다.

>>> s1 = set([1, 2, 3, 4, 5, 6])
>>> s2 = set([4, 5, 6, 7, 8, 9])
1. 교집합

s1과 s2의 교집합을 구해 보자.

>>> s1 & s2
{4, 5, 6}
"&" 기호를 이용하면 교집합을 간단히 구할 수 있다.

또는 다음과 같이 intersection 함수를 사용해도 동일한 결과를 돌려준다.

>>> s1.intersection(s2)
{4, 5, 6}
s2.intersection(s1)을 사용해도 결과는 같다.

2. 합집합

합집합은 다음과 같이 구할 수 있다. 이때 4, 5, 6처럼 중복해서 포함된 값은 한 개씩만 표현된다.

>>> s1 | s2
{1, 2, 3, 4, 5, 6, 7, 8, 9}
"|" 기호를 사용한 방법이다.

>>> s1.union(s2)
{1, 2, 3, 4, 5, 6, 7, 8, 9}
또는 union 함수를 사용하면 된다. 교집합에서 사용한 intersection 함수와 마찬가지로 s2.union(s1)을 사용해도 동일한 결과를 돌려준다.

3. 차집합

차집합은 다음과 같이 구할 수 있다.

>>> s1 - s2
{1, 2, 3}
>>> s2 - s1
{8, 9, 7}
빼기(-) 기호를 사용한 방법이다.

>>> s1.difference(s2)
{1, 2, 3}
>>> s2.difference(s1)
{8, 9, 7}
difference 함수를 사용해도 차집합을 구할 수 있다.

집합 자료형 관련 함수들
값 1개 추가하기(add)
이미 만들어진 set 자료형에 값을 추가할 수 있다. 1개의 값만 추가(add)할 경우에는 다음과 같이 한다.

>>> s1 = set([1, 2, 3])
>>> s1.add(4)
>>> s1
{1, 2, 3, 4}
값 여러 개 추가하기(update)
여러 개의 값을 한꺼번에 추가(update)할 때는 다음과 같이 하면 된다.

>>> s1 = set([1, 2, 3])
>>> s1.update([4, 5, 6])
>>> s1
{1, 2, 3, 4, 5, 6}
특정 값 제거하기(remove)
특정 값을 제거하고 싶을 때는 다음과 같이 하면 된다.

>>> s1 = set([1, 2, 3])
>>> s1.remove(2)
>>> s1
{1, 3}

# 4. 대표값
n=10
a=[45, 73, 66, 87, 92, 67, 75, 79, 75, 80]
ave=sum(a)/n
# 반올림 int(74.3) => 74, int(73.9) => 73
ave=ave+0.5
ave=int(ave)
min=2147000000
for idx, x in enumerate(a):
    # print(idx, ":", x)
    # 0 : 45
    # 1 : 73
    # 2 : 66
    # 3 : 87
    # 4 : 92
    # 5 : 67
    # 6 : 75
    # 7 : 79
    # 8 : 75
    # 9 : 80
    tmp=abs(x-ave)
    if tmp<min:
        min=tmp
        score=x
        res=idx+1
    elif tmp==min:
        # 조건을 x>score 로 걸었기 때문에 뒤에 같은 점수가 나와도 번호가 빠른 값이 출력이 됨
        if x>score:
            score=x
            res=idx+1
print(ave, res)

enumerate
리스트가 있는 경우 순서와 리스트의 값을 전달하는 기능을 가집니다.
이 함수는 순서가 있는 자료형(list, set, tuple, dictionary, string)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 리턴합니다.

data = enumerate((1, 2, 3))
print(data, type(data))
0 : 1
1 : 2
2 : 3

for i, value in data:
    print(i, ":", value)
print()
0 : 1
1 : 2
2 : 3

dict1 = {'이름': '한사람', '나이': 33}
data = enumerate(dict1)
for i, key in data:
    print(i, ":", key, dict1[key])
print()
0 : 이름 한사람
1 : 나이 33

data = enumerate("재미있는 파이썬")
for i, value in data:
    print(i, ":", value)
print()
0 : 재
1 : 미
2 : 있
3 : 는
4 :  
5 : 파
6 : 이
7 : 썬
range([strat,] stop [,step])

# 5. 정다면체
n=4
m=6
# cnt는 횟수를 구해 넣는 list
cnt=[0]*(n+m+3)
# 0 1 2 3 4 5 6 7 8 9 10 11 12
# 0 0 0 0 0 0 0 0 0 0  0  0  0 
max=0
for i in range(1, n+1):  
  for j in range(1, m+1):
    cnt[i+j]=cnt[i+j]+1

# 0 1 2 3 4 5 6 7 8 9 10 11 12
# 0 0 0 0 0 0 0 0 0 0  0  0  0
# # i=1
#     1 1 1 1 1 1
# # i=2
#       2 2 2 2 2 1
# # i=3
#         3 3 3 3 2 1
# # i=4
#           4 4 4 3 2  1
# cnt = [0 0 1 2 3 4 4 4 3 2 1 0 0]

# cnt 에서 max값 구하기
for i in range(n+m+1):
  if cnt[i]>max:
    max=cnt[i]

# max값을 기준으로 cnt에서 값과 비교하여 index 구하기
for i in range(n+m+1):
  if cnt[i]==max:
    print(i, end=' ')

# 6. 자릿수의 합
# 각 자릿수 구하는 함수
def digit_sum(x):
    sum=0
    while x>0:
        t = x%10
        sum = sum + t
        x=x//10      
    return sum

# x= 15232
# print(t, sum, x)
# 1. 2 2 1523
# 2. 3 5 152
# 3. 2 7 15
# 4. 5 12 1
# 5. 1 13 0

# 7. 소수(에라토스테네스 체)
# 1. 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.
# 2. 2는 소수이므로 오른쪽에 2를 쓴다. (빨간색)
# 3. 자기 자신을 제외한 2의 배수를 모두 지운다.
# 4. 남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다. (초록색)
# 5. 자기 자신을 제외한 3의 배수를 모두 지운다.
# 6. 남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다. (파란색)
# 7. 자기 자신을 제외한 5의 배수를 모두 지운다.
# 8. 남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다. (노란색)
# 9. 자기 자신을 제외한 7의 배수를 모두 지운다.
# 10. 위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다.
n=20
ch=[0]*(n+1)
ans=[]
cnt=0
for i in range(2, n+1):
    if ch[i]==0:
        cnt+=1
        ans.append(i)
        for j in range(i, n+1, i):
            ch[j]=1
        
print(ans, cnt)
i=2
cnt = 1
ans = [2]
for j in range(2, 20+1, 2):
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0 0 1 0 1 0 1 0 1 0 1  0  1  0  1  0  1  0  1  0  1

i=3
cnt = 2
ans = [2, 3]
for j in range(3, 20+1, 3):
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0 0 1 1 1 0 1 0 1 1 1  0  1  0  1  1  1  0  1  0  1

i=4

i=5
cnt = 3
ans = [2, 3, 5]
for j in range(5, 20+1, 5):
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0 0 1 1 1 1 1 0 1 1 1  0  1  0  1  1  1  0  1  0  1

i=6

i=7
cnt = 4
ans = [2, 3, 5, 7]
for j in range(5, 20+1, 5):
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0 0 1 1 1 1 1 1 1 1 1  0  1  0  1  1  1  0  1  0  1

i=8, i=9, i=10
i=11
cnt = 5
ans = [2, 3, 5, 7, 11]
for j in range(11, 20+1, 11):
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0 0 1 1 1 1 1 1 1 1 1  1  1  0  1  1  1  0  1  0  1

i=12
i=13
cnt = 6
ans = [2, 3, 5, 7, 11, 13]
for j in range(13, 20+1, 13):
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0 0 1 1 1 1 1 1 1 1 1  1  1  1  1  1  1  0  1  0  1

i=14, i=15, i=16
i=17
cnt = 7
ans = [2, 3, 5, 7, 11, 13, 17]
for j in range(17, 20+1, 17):
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0 0 1 1 1 1 1 1 1 1 1  1  1  1  1  1  1  1  1  0  1

i=18
i=19
cnt = 8
ans = [2, 3, 5, 7, 11, 13, 17, 19]
for j in range(19, 20+1, 19):
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
0 0 1 1 1 1 1 1 1 1 1  1  1  1  1  1  1  1  1  1  1

i=20


1. range(a,b) => a ~ b-1까지
2. ragne(b) => 0 ~ b-1까지
3. range(a,b,c) => a ~ b-1까지 c만큼 건너 뛰세요.
ex) range(0,50,5) => 0,5,10,...40,45,50

# 8.뒤집은 소수
# 수 뒤집기
def reverse(x):
    res=0
    while x>0:
        t=x%10
        # 나머지 값을 10단위 100단위로 순차적으로 올려준다.
        res=res*10+t
        x=x//10
    return res

# 9. 주사위 게임
# map()
# https://dojang.io/mod/page/view.php?id=2286
# map은 리스트의 요소를 지정된 함수로 처리해주는 함수
# map은 원본 리스트를 변경하지 않고 새 리스트를 생성
# list(map(함수, 리스트))
# tuple(map(함수, 튜플))
>>> a = [1.2, 2.5, 3.7, 4.6]
>>> a = list(map(int, a))
[1, 2, 3, 4]
>>> b = list(map(str, range(10)))
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

# ie..
# +	더하기	a + b = 30
# -	빼기	a - b = -10
# *	곱하기	a * b = 200
# /	나누기	b / a = 2.0
# %	나머지	b % a = 0
# **	제곱	a ** c = 1000
# //	몫	a // c = 3
# [..."👩‍👩‍👦‍👦"]
# (윈도우 로고키) + (마침표키) 또는 (윈도우 로고키) + (세미콜론키)